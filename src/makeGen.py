import os
import sys
import subprocess
import datetime

fileToCompile = ""
listOfcppFiles = []

usingLibrariesString = ""
compiler_flags = "-w"

# Paser and run a system command and return the output of the command
def setCompileFile():
    # Allow for fileToCompile to be written to
    global fileToCompile
    global usingLibrariesString

    # Check for the correct number of argements
    if (len(sys.argv) <= 2):
        print("Error: Incorrect number of arguments!")
        print("       Expected: at least 1    Found:", len(sys.argv) - 1)
        exit(1)

    # Extract the file name from the commandline argements
    fileName = sys.argv[1]
    if (len(sys.argv) > 2):
        usingLibrariesString = sys.argv[2]

    # If the file exists in the current directory set the global variable with the name
    if(os.path.isfile(fileName)):
        fileToCompile = fileName
    # If the file does not exists throw an error
    else:
        print("Error: File", fileName,
              "was not found in directory:", os.getcwd() + "/")
        exit(1)

# Run a system command ie Bash and return its result
def runSysCmd(commandString):
    splitStr = commandString.split()
    return str(subprocess.check_output(splitStr))

# Generate a list of all of the cpp files in the project directory
def findCppFiles(dirName=None):

    # Make listOfcppFiles writable
    global listOfcppFiles

    # List of all of the cpp files we have
    fileNames = []

    # A list of all the directories in the current directory
    directorysToVisit = []

    # Get a list of all of the files and folders in the current directory
    if(dirName is not None):
        dirList = os.listdir(dirName)
    else:
        dirList = os.listdir()


    dirListSorted = []


    # Sort all of the .cpp files into the dirListSorted
    for item in dirList:
        if (".cpp" in item):
            dirListSorted.append(item)

    # Sort all of the directorys into dirListSorted
    for item in dirList:
        if (dirName is not None):
            if(os.path.isdir(dirName + "/" + item)):
                dirListSorted.append(item)
        else:
            if(os.path.isdir(item)):
                dirListSorted.append(item)

    # Go through all of the items in the current directory
    for item in dirListSorted:

        # Check if we are in a sub directory. If so use the path from currend working directory
        if (dirName is not None):
            # If the item is a directory add it to the list of directorys
            if(os.path.isdir(dirName + "/"+ item)):
                directorysToVisit.append(item)
            # If it is a C++ source file and it is not the main file we are compiling add it to the list of files
            elif(".cpp" in item and item != fileToCompile):
                fileNames.append(dirName+"/"+item)

        else:

            # If the item is a directory add it to the list of directorys
            if(os.path.isdir(item)):
                directorysToVisit.append(item)
            # If it is a C++ source file and it is not the main file we are compiling add it to the list of files
            elif(".cpp" in item and item != fileToCompile):
                fileNames.append(item)

    if(len(directorysToVisit) > 0):
        # Go through all of the directories we found and find all of their files and directories
        for directory in directorysToVisit:
            # Get all of the files from the below directory
            if (dirName is not None):
                prevFiles = findCppFiles(dirName=dirName + "/" + directory)
            else:
                prevFiles = findCppFiles(dirName=directory)
            # Add each file to the file list
            for fileFound in prevFiles:
                fileNames.append(fileFound)

    listOfcppFiles = fileNames

    return fileNames

# Use g++ -MM to generate a list of dependancies for the file
def getMakeLine(fileName):
    # If this fails and throws an exception that means g++ threw an error which needs to be fixed
    try:
        # Get the make dependancies from g++ -MM
        completeLine = runSysCmd("g++ -MM " + fileName)
        # Get rid of some artifacts that g++ throws out
        completeLine = str(completeLine).replace("\\n","").replace("\\ ","").replace("b\'","").replace("\'","").replace("\\","")
        return completeLine
    except:
        exit(1)

# Write information about the make file into it
def writeMakeFileInformation(f):

    currentDate = datetime.datetime.now()

    f.write("# This file was autogenerated by makeGen.py\n")
    f.write("# Author: Aaron Jost\n")
    f.write("# Date Generated: " + str(currentDate.day) + "/" + str(currentDate.month) + "/" + str(currentDate.year) + " @ " + str(currentDate.hour) + ":" + str(currentDate.minute) + "\n\n" )


    return 0;

# Write the make file
def genMakeFile():
    # Storage varable for object file information
    # contents [["example.o","exampleDep.cpp exampleDep.hpp ..." ] ... ]
    dotOlines = []

    # For every cpp file do the following
    for cppFile in listOfcppFiles:

        # Generate the make line
        completeLine = getMakeLine(cppFile)

        # Separate the object.o file name and its dependancies
        oFileName = completeLine.split(":")[0]
        oFileDeps = completeLine.split(":")[1].strip()

        # Append the information to the object file information Storage varable
        dotOlines.append([oFileName,oFileDeps])

    # Generate a list of all the object files we need to generate
    objFileList = ""
    for objFiles in dotOlines:
        objFileList += objFiles[0] + " "

    # Storage variable for an unorganized list of all the directories we are pulling source files from
    directorysList = []
    # Organized list of the above list. [cppFiles , ... , directories , ...]
    replaceDirPaths = []

    # Generate a list of all directories
    for currentCppFile in listOfcppFiles:

        # In the current cppFile with path. Get just the path part of it without the cppFile
        indexOfLast = currentCppFile.rfind("/")+1
        dirFound = currentCppFile[0:indexOfLast]

        # If that directory has not been found before add it to the list of directories
        if (dirFound not in directorysList):
            directorysList.append(dirFound)

    # Open a file to write the makefile into
    f = open("makefile","w")

    writeMakeFileInformation(f)

    # Write a variable into the make file with the compiler flags we want
    f.write("COMPILER_FLAGS = "+compiler_flags + "\n")

    # Go through all of the directories and see if there are any file paths we can assign to a variable to reduce the length of the makefile code
    for Direct in directorysList:
        # If the number of directories transversed by the path is more than one make it into variable
        if(Direct.count("/") > 1):
            # Take off the last / in the path
            dirsUsed = Direct.split("/")[0:-1]
            # initalize a variable for the reconstructed path
            reconstructed = ""
            # For each directory define a variable for it in the make file
            for item in dirsUsed:
                reconstructed += item + "/"
                replaceDirPaths.append(reconstructed)
            # Write the variable to the make file
            f.write(str((dirsUsed[-1] + "_DIR").upper()) + " = " + reconstructed[0:-1] + "\n")

    f.write("\n")

    # Write the final compilation definition for target file
    f.write("# Does all of the linking and compilation of " + fileToCompile + ".\n")
    f.write("out: " +fileToCompile + " " + objFileList+"\n")
    f.write("\tg++ "+ "$(COMPILER_FLAGS)" + " " + fileToCompile + " " + objFileList+"-o out "+ usingLibrariesString+"\n\n")

    # Wrte the cleanup definitions for pre-compiled headers
    f.write("# Used for cleaning up all of the precompiled headers.\n")
    f.write("clean:\n")
    for cleanDir in directorysList:
        f.write("\trm -rf "+cleanDir+"*.gch\n")
    f.write("\n")

    # Write the cleanup definitions for the object files
    f.write("# Used for cleaning up all of the object files.\n")
    f.write("cleanAll:\n")
    f.write("\trm -rf *.o\n")


    # Generate code for all of the object files
    lastDir = ""

    for dep in dotOlines:
        objectDefinitionLineElement = dep[1].split()[0]
        indexOfLast = objectDefinitionLineElement.rfind("/")+1
        dirFound = objectDefinitionLineElement[0:indexOfLast]
        currentIndex = dotOlines.index(dep)

        # Check if any of the parts in the directory have been defined as variables to save space
        for replacment in replaceDirPaths:
            if (replacment in dep[1] and dirFound.count("/") > 1 and replacment.count("/") > 1):
                indexOfReplacment = dotOlines.index(dep)
                VarName = replacment.split("/")[-2]
                dotOlines[indexOfReplacment][1] = dotOlines[indexOfReplacment][1].replace(replacment[0:-1],"$("+VarName.upper() + "_DIR)")

        if(dirFound != lastDir or dirFound == ""):
            if(dirFound == ""):
                dirFound = "Souce Directory"
            f.write("\n#" + "-"*27 + "-"*(len(dirFound)-1) + "\n")
            f.write("#------------ " + dirFound + " ------------\n")
            f.write("#" + "-"*27 + "-"*(len(dirFound)-1) + "\n")
            lastDir = dirFound

        f.write(dep[0] + ": "+ dotOlines[currentIndex][1]+"\n")
        f.write("\tg++ "+ "$(COMPILER_FLAGS)"+" -c "+ dotOlines[currentIndex][1] +"\n")

    f.close()

setCompileFile()
findCppFiles()
genMakeFile()
